@[TOC]
# 1、Makefile 作用
Windows操作系统下做嵌入式开发时，可以使用keil，通过软件帮助我们管理对文件项目，完成预处理->编译->汇编->链接，但在Linux系统下，由.c文件得到可执行文件需要通过命令行输入gcc命令完成，通常形式为`gcc -o obj a.c`，表示使用gcc编译a.c文件，生成可执行文件obj，其中经过了四个过程：
**预处理**：.c文件->.i文件  `gcc -E 依赖.c -o 目标.i`
**编译**：.i文件->.s文件  `gcc -S 依赖.i -o 目标.s`
**汇编**：.s文件->.o文件  `gcc -c 依赖.s -o 目标.o`
**链接**：.o文件->可执行文件  `gcc 依赖.o -o 目标.exe`
> 注：`gcc -o obj a.c -v`可以输出处理过程信息

当我们的目标可执行文件依赖于多个.c文件时，需要将每个.c文件都注明，且每次修改其中一个文件都要把所有依赖的.c文件都重新编译`gcc -o obj a.c b.c c.c d.c ……`，极其不方便，若通过命令行记录重新执行又会把没有修改的文件也都重新处理一遍，当项目比较大的时候，就会耗费资源。
# 2、Makefile 语法
## 2.1 基本语法形式
	目标:依赖1 依赖2……
	[TAB]命令
例如：
```bash
obj:a.o b.o
	gcc -o obj a.o b.o
a.o:a.c
    gcc -c -o a.o a.c
b.o:b.c
    gcc -c -o b.o b.c
clean:
    rm -rf *.o obj
```
## 2.2 通配符及语法解析
- **通配符**
不难发现，上一节中的示例文件中，生成a.o和b.o的语句极为相像，若最终目标依赖许许多多的.o文件，是否需要每个都使用一条单独的语句生成呢？答案当然是否定的，否则Makefile文件相较于命令行直接输入的优势就无法体现了。
上一节的文件可转换成如下的等效写法：
```bash
obj:a.o b.o				#               通配符说明
	gcc -o obj $^       # $<：表示第一个依赖文件
%.o:%.c					# %.o：表示所有的.o文件；%.c：表示所有的.c文件
    gcc -c -o $@ $<     # $@：表示目标文件；$^：表示所有依赖文件
clean:
    rm -rf *.o obj
```
执行`make`则生成目可执行文件`obj`，执行`make clean`则删除可执行文件及所有.o文件

- 变量定义
```bash
# 简单变量（即时变量）：定义时确定变量的值
var := xxx
# 延时变量：变量被使用时确定变量的值
var = xxx
```
例如：
```bash
CC := $(A)
A = gcc

obj: a.c
	$(CC) -o $@ $^    # 使用 $(CC) 引用变量 CC
	
# 无法正常运行，因为 CC 是即时变量，在定义时变量 A 为空，所以变量 CC 也为空
```
```bash
CC = $(A)
A = gcc

obj: a.c
	$(CC) -o $@ $^    # 使用 $(CC) 引用变量 CC
	
# 正常运行，因为 CC 是延时变量，在 $(CC) 调用变量时才确定其值等于变量 A
# 而此时变量 A 由于被使用，确定为等于 gcc，即 CC 等于 gcc
```

除此以外，还有以下常见变量定义：
```bash
var ?= xxx		# 延时变量，当该语句为首次定义变量时才有效
var += xxx		# 附加变量，是即时还是延时取决于变量最初定义时属性
var ?=: xxx		# 即时变量，当该语句为首次定义变量时才有效
```

>欢迎批评指正！！！
> 参考文献：[韦东山-Makefile的语法](https://www.bilibili.com/opus/108508955711625306?spm_id_from=333.999.collection.opus.click)
> 
